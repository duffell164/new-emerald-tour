<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>New Emerald Tour Leaderboard</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lipis/flag-icons@7.0.2/css/flag-icons.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    
    <style>
        .leaderboard-container {
            max-width: 1300px;
            margin: 0 auto;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
		.header {
			background: linear-gradient(135deg, #124d12 0%, #228B22 50%, #1a5e1a 100%);
			color: white;
			padding: 25px 150px !important;
			text-align: center;
			font-size: 28px;
			font-weight: 800;
			text-transform: uppercase;
			letter-spacing: 3px;
			border-bottom: 4px solid #FFD700;
			position: relative;
			min-height: 80px;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.header img {
			position: absolute;
			top: 50%;
			transform: translateY(-50%);
			height: 50px;
			width: auto;																				 
		}
		.header {
			padding: 25px 80px !important;
		}
		.logo-left { left: 40px; }
		.logo-right { right: 50px; }

		@media (max-width: 600px) {
			.header img { display: none; padding: 20px !important; }
		}
        .info-bar {
            display: flex;
            justify-content: space-around;
            background: linear-gradient(90deg, #333 0%, #444 50%, #333 100%);
            color: #ddd;
            padding: 12px 15px;
            border-bottom: 1px solid #444;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .info-item {
            font-weight: bold;
            color: #FFD700;
        }
        .info-item span {
            font-weight: normal;
            color: white;
            margin-left: 8px;
        }
        .prize-pool {
            color: #FFD700 !important;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
        }
        .venue {
            background: linear-gradient(90deg, #333 0%, #444 50%, #333 100%);
            color: #FFFFF7;
            padding: 12px 15px;
            text-align: center;
            font-size: 18px;
            font-family: 'Segoe UI', sans-serif;
            font-weight: bold;
            border-bottom: 1px solid #000;
            letter-spacing: 1px;
        }
        .venue.major {
            background: linear-gradient(90deg, #8B6914 0%, #FFD700 50%, #8B6914 100%) !important;
            color: #000 !important;
            text-shadow: none;
            box-shadow: inset 0 0 15px rgba(255,255,255,0.5);
        }
        .controls {
            padding: 10px 15px;
            background-color: #228B22;
            text-align: center;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .controls button {
            padding: 8px 16px;
            font-size: 14px;
            background-color: #006400;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .controls button:hover { background-color: #2e8b57; }
        .controls button.clear-season { background-color: #8b0000; }
        .controls button.clear-season:hover { background-color: #5e0000; }
        .player-input {
            padding: 10px 15px;
            background-color: #f0f0f0;
            text-align: center;
        }
        .player-input input { padding: 8px; width: 300px; font-size: 16px; }
        .player-input button {
            padding: 8px 16px;
            font-size: 14px;
            background-color: #006400;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }
		.fa-playstation { color: #003791 !important; text-shadow: 0 0 5px rgba(0, 55, 145, 0.3); }
		.fa-xbox { color: #107c10 !important; text-shadow: 0 0 5px rgba(16, 124, 16, 0.3); }
		.fa-steam { color: #171a21 !important; }
		.fa-gamepad { color: #555 !important; }
		.console-icon:hover {
			transform: scale(1.2);
			filter: brightness(1.2);
			filter: drop-shadow(0 0 2px currentColor);
			transition: transform 0.2s ease;
		}
        table { width: 100%; border-collapse: collapse; }
        th {
            background-color: #e6e6e6;
            padding: 12px;
            text-align: left;
            font-weight: bold;
            font-size: 14px;
            border-bottom: 2px solid #ddd;
        }
        td {
            padding: 8px 12px;
            border-bottom: 1px solid #ddd;
            font-size: 16px;
        }
        tr:hover { background-color: #f9f9f9; }

        /* ‚îÄ‚îÄ TO PAR COLUMN ‚îÄ‚îÄ now has the same light grey background as the header row ‚îÄ‚îÄ */
        .to-par {
            font-weight: bold;
            text-align: center;
            width: 20px;
            min-width: 20px;
            font-size: 18px;
            color: #000;
        }
        .to-par.under { color: #8B0000; }   /* red = under par */
        .to-par.even   { color: #1AA260; }  /* green = even */
        .to-par.over   { color: #000000; }  /* black = over par */

        /* No-score case (shows "-") */
        .to-par:not(.under):not(.even):not(.over) {
            color: #444;
        }

        .pos { font-weight: bold; width: 60px; text-align: center; }
        .player { font-weight: bold; width: 320px; position: relative; }
        .player-content { display: flex; align-items: center; gap: 8px; }
        .console-icon { cursor: pointer; width: 22px; text-align: center; color: #555; font-size: 18px; }
        .fi { cursor: pointer; border-radius: 2px; flex-shrink: 0; }
        .country-input {
            width: 35px;
            text-align: center;
            font-size: 12px;
            text-transform: uppercase;
            border: 1px solid #ccc;
            display: none;
        }
        .player-text { flex-grow: 1; }
        .round-score { text-align: center; width: 80px; }
		.score-input {
			width: 60px;
			font-weight: normal;
			text-align: center;
			border: none;
			background: transparent;
			font-size: 16px;
			-moz-appearance: textfield;          /* Firefox */
		}

		/* Remove spinners in Chrome, Edge, Safari, Opera */
		.score-input::-webkit-outer-spin-button,
		.score-input::-webkit-inner-spin-button {
			-webkit-appearance: none;
			margin: 0;
		}

		/* Ensure no outline weirdness on focus */
		.score-input:focus {
			outline: 2px solid #003087;
			background-color: #f0f8ff;
		}
        .total, .prize {
            font-weight: normal;
            text-align: center;
            width: 100px;
        }
        .prize, .season-earnings {
            color: #000;
            font-weight: bold;
            text-align: center;
        }
        .total-header, .prize-header {
            font-weight: bold;
            text-align: center !important;
            font-size: 14px !important;
        }
        .editable { cursor: pointer; min-width: 50px; }
        .editable:focus {
            outline: 2px solid #003087;
            background-color: #f0f8ff;
        }
        .hidden { display: none; }

        /* rest of your styles unchanged */
        .bonus-table-container { margin-top: 30px; }
        .bonus-header { background-color: #E8E8E8; color: black; padding: 12px; font-size: 18px; font-weight: bold; text-align: left; border-bottom: 1px solid #ddd; }
        .history-header { background-color: #228B22; color: white; padding: 12px; font-size: 18px; font-weight: bold; text-align: left; border-bottom: 1px solid #ddd; cursor: pointer; user-select: none; }
        .history-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .history-table th { background-color: #d0e8d0; text-align: center; }
        .history-table td { text-align: center; }
        .history-container { margin-top: 30px; }
        .bonus-table th { background-color: #d0e8d0; text-align: center; }
        .bonus-table th.player, .bonus-table td.player { text-align: left !important; font-weight: bold; }
        .bonus-table th.season-earnings { width: 180px; text-align: center; }
        .bonus-table th.fir, .bonus-table th.gir, .bonus-table th.scrambling, .bonus-table th.ntp,
        .bonus-table td.fir, .bonus-table td.gir, .bonus-table td.scrambling, .bonus-table td.ntp { width: 120px; text-align: center; }
        .bonus-input { text-align: center; }
        .bonus-winner { background-color: #B3D9D9 !important; font-weight: bold; color: #000; }
        .season-points { width: 160px; text-align: center; font-weight: bold; color: #000; }
        .delete-btn {
            background-color: #c00;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 3px 8px;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            margin-left: auto;
        }
        .player:hover .delete-btn { opacity: 1; }
        .season-events { width: 100px; text-align: center; font-weight: bold; color: #000; }
        .season-top50 {
            background: linear-gradient(to bottom, #e8f5e9 0%, #c8e6c9 50%, #a5d6a7 100%) !important;
            border-bottom: 1px solid #81c784;
        }
        .season-top50-bottom-border { border-bottom: 4px solid #000 !important; }
        .leaderboard-highlight {
            background: linear-gradient(to bottom, #f5f5f5 0%, #e0e0e0 50%, #d1d1d1 100%) !important;
            border-bottom: 1px solid #bcbcbc;
        }
        .leaderboard-highlight-bottom { border-bottom: 1px solid #666 !important; }
        .hof-container {
            margin-top: 40px;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a1a 0%, #333 100%);
            border-radius: 12px;
            color: white;
        }
        .hof-header {
            text-align: center;
            font-size: 28px;
            color: #FFD700;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 25px;
            border-bottom: 2px solid #FFD700;
            padding-bottom: 10px;
        }
        .hof-cards {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            flex-wrap: wrap;
        }
        .hof-card {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            padding: 20px;
            width: 250px;
            text-align: center;
            transition: transform 0.3s;
        }
        .hof-stat span { color: #FFD700; font-weight: bold; }
    </style>
</head>
    </style>
</head>
<body>
		<div class="leaderboard-container">
			<div class="header">	
				<img src="2k25 logo.png" class="logo-left" alt="2K25 Logo">
				
				<span id="header-text-content" contenteditable="true">
					<span style="color: #FFD700;">‚óè</span> New Emerald Tour Leaderboard
				</span>

				<img src="FedEx-Cup-logo.png" class="logo-right" alt="PGA Tour Logo">
			</div>
        <div class="info-bar">
            <div class="info-item">Date: <span id="date-field" contenteditable="true"></span></div>
            <div class="info-item">Course Par: <span id="course-par" contenteditable="true">72</span></div>
            <div class="info-item prize-pool">Prize Pool: <span id="prize-pool">$500,000</span></div>
        </div>
        <div class="venue" contenteditable="true">Season 1, Week 1 - Ritz-Carlton Golf Club, Orlando, FL</div>
        <div class="player-input">
            <input type="text" id="new-player-name" placeholder="Enter player name">
            <button id="add-player">Add Player</button>
        </div>
        <div class="controls">
            <button id="toggle-r3-r4">Show Rounds 3 & 4</button>
            <button id="new-tournament">New Tournament (Reset Scores Only)</button>
            <button id="clear-season" class="clear-season">Clear Season Earnings</button>
            <button id="export-json">Export Backup (JSON)</button>
            <button id="import-json">Import Backup (JSON)</button>
            <button id="export-png">Export Leaderboard as Image (PNG)</button>
        </div>
        <table id="leaderboard-table">
            <thead>
                <tr>
                    <th class="pos">POS</th>
                    <th>PLAYER</th>
                    <th class="to-par">TO PAR</th>
                    <th class="round-score">R1</th>
                    <th class="round-score">R2</th>
                    <th class="round-score hidden" id="th-r3">R3</th>
                    <th class="round-score hidden" id="th-r4">R4</th>
                    <th class="total total-header">TOTAL</th>
                    <th class="prize prize-header">PRIZE (v$)</th>
                </tr>
            </thead>
            <tbody id="leaderboard-body"></tbody>
        </table>
        <div class="bonus-table-container">
            <div class="bonus-header" id="season-header">SEASON STATS (Events: 0)</div>
            <table id="bonus-table" class="bonus-table">
                <thead>
                    <tr>
                        <th class="player">PLAYER</th>
                        <th class="season-points">SEASON POINTS</th>
                        <th class="season-earnings">SEASON TOTAL (v$)</th>
                        <th class="season-events">EVENTS ENTERED</th>
                        <th class="fir">FiR % (v$20k)</th>
                        <th class="gir">GiR % (v$20k)</th>
                        <th class="scrambling">Scrambling % (v$20k)</th>
                        <th class="ntp">Nearest the Pin (ft) (v$20k)</th>
                    </tr>
                </thead>
                <tbody id="bonus-body"></tbody>
            </table>
        </div>
        <div class="history-container">
            <div class="history-header" id="history-toggle">Season Event History ‚ñº</div>
            <table id="history-table" class="history-table hidden">
                <thead>
                    <tr>
                        <th>Event</th>
                        <th>Venue</th>
                        <th>Date</th>
                        <th>Prize Pool</th>
                        <th>Winner</th>
                        <th>Winning Prize</th>
                        <th>Field Size</th>
                    </tr>
                </thead>
                <tbody id="history-body"></tbody>
            </table>
        </div>

        <div class="hof-container">
            <div class="hof-header">üèÜ Emerald Tour Hall of Fame üèÜ</div>
            <div class="hof-cards" id="hof-display"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <script>
        const tableBody = document.getElementById('leaderboard-body');
        const bonusBody = document.getElementById('bonus-body');
        const historyBody = document.getElementById('history-body');
        const historyTable = document.getElementById('history-table');
        const historyToggle = document.getElementById('history-toggle');
        const courseParElement = document.getElementById('course-par');
        const dateField = document.getElementById('date-field');
        const venueField = document.querySelector('.venue');
        const headerField = document.querySelector('.header');
        const prizePoolElement = document.getElementById('prize-pool');
        const seasonHeader = document.getElementById('season-header');
        const toggleButton = document.getElementById('toggle-r3-r4');
        const newTournamentButton = document.getElementById('new-tournament');
        const clearSeasonButton = document.getElementById('clear-season');
        const addPlayerButton = document.getElementById('add-player');
        const newPlayerInput = document.getElementById('new-player-name');
        let showR3R4 = false;

        const STORAGE_KEY = 'golfLeaderboardData';
        const PRIZE_KEY = 'golfCurrentPrizePool';
        const SEASON_EARNINGS_KEY = 'golfSeasonEarnings';
        const SEASON_POINTS_KEY = 'golfSeasonPoints';
        const SEASON_EVENTS_KEY = 'golfSeasonEvents';
        const EVENT_COUNT_KEY = 'golfEventCount';
        const HISTORY_KEY = 'golfEventHistory';

        let seasonEarnings = JSON.parse(localStorage.getItem(SEASON_EARNINGS_KEY) || '{}');
        let seasonPoints = JSON.parse(localStorage.getItem(SEASON_POINTS_KEY) || '{}');
        let seasonEvents = JSON.parse(localStorage.getItem(SEASON_EVENTS_KEY) || '{}');
        let eventHistory = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');

        const BASE_BONUS_CASH = 20000;

        const pointsTable = [
            500, 300, 190, 135, 110, 100, 95, 90, 85, 80, 75, 70, 65, 60, 57,
            54, 51, 48, 45, 42, 39, 36, 33, 30, 27, 24, 21, 18, 16, 15,
            14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
        ];

        const payoutPercentages = [
            0, 18.00, 10.90, 6.90, 4.90, 4.10, 3.70, 3.40, 3.10,
            2.90, 2.70, 2.50, 2.30, 2.10, 2.00, 1.90, 1.70
        ];

        function isMajor() {
            return /major/i.test(venueField.textContent);
        }

        function getBonusCash() {
            return isMajor() ? BASE_BONUS_CASH * 2 : BASE_BONUS_CASH;
        }

        function getCurrentPrizePool() {
            const saved = localStorage.getItem(PRIZE_KEY);
            return saved ? parseInt(saved) : 500000;
        }

        function updatePrizePoolDisplay() {
            let pool = getCurrentPrizePool();
            if (isMajor()) pool *= 2;
            prizePoolElement.textContent = '$' + pool.toLocaleString();
        }

        function increasePrizePool() {
            let current = getCurrentPrizePool();
            current += 100000;
            localStorage.setItem(PRIZE_KEY, current.toString());
            updatePrizePoolDisplay();
        }

        function resetPrizePool() {
            localStorage.setItem(PRIZE_KEY, '500000');
            updatePrizePoolDisplay();
        }

        function getEventCount() {
            const saved = localStorage.getItem(EVENT_COUNT_KEY);
            return saved ? parseInt(saved) : 0;
        }

        function increaseEventCount() {
            let count = getEventCount();
            count += 1;
            localStorage.setItem(EVENT_COUNT_KEY, count.toString());
            updateSeasonHeader(count);
        }

        function resetEventCount() {
            localStorage.setItem(EVENT_COUNT_KEY, '0');
            updateSeasonHeader(0);
        }

        function updateSeasonHeader(count) {
            seasonHeader.textContent = `SEASON STATS (Events: ${count})`;
        }

        function addToHistory() {
            const pool = getCurrentPrizePool() * (isMajor() ? 2 : 1);
            const date = dateField.textContent.trim();
            const venue = venueField.textContent.trim();
            const scoredRows = Array.from(tableBody.children).filter(row => calculateToPar(row) !== null);
            const scoringPlayers = scoredRows.length;
            let winner = '';
            let winningPrize = '$0';
            if (scoredRows.length > 0) {
                scoredRows.sort((a, b) => calculateToPar(a) - calculateToPar(b));
                const firstPrizeCell = scoredRows[0].querySelector('[data-type="prize"]');
                winningPrize = firstPrizeCell.textContent.trim();
                const firstToPar = calculateToPar(scoredRows[0]);
                const winners = scoredRows.filter(row => calculateToPar(row) === firstToPar);
                if (winners.length === 1) {
                    winner = winners[0].querySelector('.player-text').textContent.trim();
                } else {
                    winner = `Tied (${winners.length} players)`;
                }
            }
            const eventNum = getEventCount() + 1;
            const entry = {
                event: eventNum,
                venue: venue,
                date: date,
                pool: '$' + pool.toLocaleString(),
                winner: winner,
                prize: winningPrize,
                scoringPlayers: scoringPlayers
            };
            eventHistory.unshift(entry);
            localStorage.setItem(HISTORY_KEY, JSON.stringify(eventHistory));
            renderHistory();
        }

        function renderHistory() {
            historyBody.innerHTML = '';
            eventHistory.forEach(entry => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${entry.event}</td>
                    <td>${entry.venue}</td>
                    <td>${entry.date}</td>
                    <td>${entry.pool}</td>
                    <td>${entry.winner}</td>
                    <td>${entry.prize}</td>
                    <td>${entry.scoringPlayers}</td>
                `;
                historyBody.appendChild(tr);
            });
            historyTable.classList.toggle('hidden', eventHistory.length === 0);
        }

        function clearHistory() {
            eventHistory = [];
            localStorage.removeItem(HISTORY_KEY);
            renderHistory();
        }

        function updateVenueStyle() {
            if (isMajor()) {
                venueField.classList.add('major');
            } else {
                venueField.classList.remove('major');
            }
            updatePrizePoolDisplay();
        }

        function getSeasonEarnings(playerName) {
            return seasonEarnings[playerName] || 0;
        }

        function addToSeasonEarnings(playerName, amount) {
            if (!playerName || amount <= 0) return;
            seasonEarnings[playerName] = (seasonEarnings[playerName] || 0) + amount;
            localStorage.setItem(SEASON_EARNINGS_KEY, JSON.stringify(seasonEarnings));
        }

        function getSeasonPoints(playerName) {
            return seasonPoints[playerName] || 0;
        }

        function addToSeasonPoints(playerName, points) {
            if (!playerName || points <= 0) return;
            seasonPoints[playerName] = (seasonPoints[playerName] || 0) + points;
            localStorage.setItem(SEASON_POINTS_KEY, JSON.stringify(seasonPoints));
        }

        function getSeasonEvents(playerName) {
            return seasonEvents[playerName] || 0;
        }

        function addToSeasonEvents(playerName) {
            if (!playerName) return;
            seasonEvents[playerName] = (seasonEvents[playerName] || 0) + 1;
            localStorage.setItem(SEASON_EVENTS_KEY, JSON.stringify(seasonEvents));
        }

        function clearSeasonEarnings() {
            if (confirm('Are you sure you want to clear ALL season earnings, points, events played, prize pool, event count and history? This cannot be undone.')) {
                seasonEarnings = {};
                seasonPoints = {};
                seasonEvents = {};
                localStorage.removeItem(SEASON_EARNINGS_KEY);
                localStorage.removeItem(SEASON_POINTS_KEY);
                localStorage.removeItem(SEASON_EVENTS_KEY);
                resetPrizePool();
                resetEventCount();
                clearHistory();
                sortAndRender();
            }
        }

        function createMainRow(playerData) {
            const tr = document.createElement('tr');
            tr.dataset.player = playerData.name.trim();
            
            const posTd = document.createElement('td');
            posTd.className = 'pos editable';
            posTd.contentEditable = 'true';
            tr.appendChild(posTd);

            const playerTd = document.createElement('td');
            playerTd.className = 'player';
            const contentDiv = document.createElement('div');
            contentDiv.className = 'player-content';

            const consoleIcon = document.createElement('i');
            const consoles = ['fa-gamepad', 'fa-playstation', 'fa-xbox', 'fa-steam'];
            consoleIcon.className = `console-icon fa-brands ${playerData.console || 'fa-gamepad'}`;
            consoleIcon.title = "Cycle Console";
            consoleIcon.onclick = () => {
                let idx = consoles.indexOf(consoleIcon.classList[2]);
                // Cycle to the next console in the array
                const nextConsole = consoles[(idx + 1) % consoles.length];
                consoleIcon.className = `console-icon fa-brands ${nextConsole}`;
                
                // Visual feedback: brief pop animation
                consoleIcon.style.transform = 'scale(1.3)';
                setTimeout(() => { consoleIcon.style.transform = 'scale(1)'; }, 200);
                
                saveData();
            };
            contentDiv.appendChild(consoleIcon);

            const flagSpan = document.createElement('span');
            flagSpan.className = `fi fi-${(playerData.country || 'un').toLowerCase()}`;
            flagSpan.title = "Click to change flag";
            contentDiv.appendChild(flagSpan);

            const countryInput = document.createElement('input');
            countryInput.className = 'country-input';
            countryInput.maxLength = 2;
            countryInput.value = playerData.country || '';
            flagSpan.onclick = () => { countryInput.style.display = 'inline-block'; countryInput.focus(); };
            countryInput.onblur = () => {
                countryInput.style.display = 'none';
                flagSpan.className = `fi fi-${(countryInput.value || 'un').toLowerCase()}`;
                saveData();
            };
            contentDiv.appendChild(countryInput);

            const playerText = document.createElement('span');
            playerText.className = 'player-text editable';
            playerText.contentEditable = 'true';
            playerText.textContent = playerData.name;
            contentDiv.appendChild(playerText);

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'X';
            deleteBtn.className = 'delete-btn';
            deleteBtn.onclick = (e) => {
                e.preventDefault();
                const currentName = tr.dataset.player.trim();
                if (confirm(`Delete player "${currentName}"?`)) {
                    tr.remove();
                    const bonusRow = bonusBody.querySelector(`tr[data-player="${currentName}"]`);
                    if (bonusRow) bonusRow.remove();
                    delete seasonEarnings[currentName];
                    delete seasonPoints[currentName];
                    delete seasonEvents[currentName];
                    localStorage.setItem(SEASON_EARNINGS_KEY, JSON.stringify(seasonEarnings));
                    localStorage.setItem(SEASON_POINTS_KEY, JSON.stringify(seasonPoints));
                    localStorage.setItem(SEASON_EVENTS_KEY, JSON.stringify(seasonEvents));
                    sortAndRender();
                }
            };
            contentDiv.appendChild(deleteBtn);
            playerTd.appendChild(contentDiv);
            tr.appendChild(playerTd);

            const toParTd = document.createElement('td');
            toParTd.className = 'to-par';
            toParTd.dataset.type = 'topar';
            tr.appendChild(toParTd);

            ['r1', 'r2', 'r3', 'r4'].forEach((roundKey, i) => {
                const td = document.createElement('td');
                td.className = 'round-score' + (i >= 2 ? ' hidden' : '');
                const input = document.createElement('input');
                input.type = 'number';
                input.className = 'score-input';
                input.value = playerData[roundKey] || '';
                input.dataset.round = roundKey;
                td.appendChild(input);
                tr.appendChild(td);
            });

            const totalTd = document.createElement('td');
            totalTd.className = 'total';
            totalTd.dataset.type = 'total';
            totalTd.textContent = '-';
            tr.appendChild(totalTd);

            const prizeTd = document.createElement('td');
            prizeTd.className = 'prize';
            prizeTd.dataset.type = 'prize';
            prizeTd.textContent = '$0';
            tr.appendChild(prizeTd);

            return tr;
        }

        function createBonusRow(playerData) {
            const tr = document.createElement('tr');
            tr.dataset.player = playerData.name.trim();
            const points = getSeasonPoints(playerData.name);
            const earnings = getSeasonEarnings(playerData.name);
            const events = getSeasonEvents(playerData.name);
            tr.innerHTML = `
                <td class="player">${playerData.name}</td>
                <td class="season-points">${points.toLocaleString()}</td>
                <td class="season-earnings">$ ${earnings.toLocaleString()}</td>
                <td class="season-events">${events}</td>
                <td class="editable bonus-input fir" contenteditable="true">${playerData.fir || ''}</td>
                <td class="editable bonus-input gir" contenteditable="true">${playerData.gir || ''}</td>
                <td class="editable bonus-input scrambling" contenteditable="true">${playerData.scrambling || ''}</td>
                <td class="editable bonus-input ntp" contenteditable="true">${playerData.ntp || ''}</td>
            `;
            return tr;
        }

        function saveData() {
            const players = [];
            tableBody.querySelectorAll('tr').forEach(row => {
                const name = row.querySelector('.player-text').textContent.trim();
                const inputs = row.querySelectorAll('.score-input');
                const bonusRow = [...bonusBody.querySelectorAll('tr')].find(br => br.dataset.player === name);
                players.push({
                    name: name,
                    console: row.querySelector('.console-icon').classList[2],
                    country: row.querySelector('.country-input').value,
                    r1: inputs[0].value.trim(),
                    r2: inputs[1].value.trim(),
                    r3: inputs[2].value.trim(),
                    r4: inputs[3].value.trim(),
                    fir: bonusRow ? bonusRow.querySelector('.fir').textContent.trim() : '',
                    gir: bonusRow ? bonusRow.querySelector('.gir').textContent.trim() : '',
                    scrambling: bonusRow ? bonusRow.querySelector('.scrambling').textContent.trim() : '',
                    ntp: bonusRow ? bonusRow.querySelector('.ntp').textContent.trim() : ''
                });
            });
            const data = {																
                header: document.getElementById('header-text-content').textContent.trim(),
                date: dateField.textContent.trim(),
                venue: venueField.textContent.trim(),
                coursePar: courseParElement.textContent.trim(),
                showR3R4: showR3R4,
                players: players
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }

        function getCurrentLocalDate() {
            return new Date().toLocaleDateString('en-GB', { year: 'numeric', month: 'long', day: 'numeric' });
        }

        function loadData() {
            updatePrizePoolDisplay();
            updateSeasonHeader(getEventCount());
            renderHistory();
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) {
                dateField.textContent = getCurrentLocalDate();			 
                headerField.textContent = 'New Emerald Tour Leaderboard';
                updateVenueStyle();
                return false;
            }
            const data = JSON.parse(saved);
            const headerText = document.getElementById('header-text-content');
			if (headerText) {
				headerText.textContent = data.header || 'New Emerald Tour Leaderboard';
			}
            dateField.textContent = data.date || getCurrentLocalDate();
            venueField.textContent = data.venue || 'Season 1, Week 1 - Ritz-Carlton Golf Club, Orlando, FL';
            courseParElement.textContent = data.coursePar || '72';
            tableBody.innerHTML = '';
            bonusBody.innerHTML = '';
            (data.players || []).forEach(p => {
                const mainRow = createMainRow(p);
                const bonusRow = createBonusRow(p);
                tableBody.appendChild(mainRow);
                bonusBody.appendChild(bonusRow);
            });
            showR3R4 = data.showR3R4 || false;
            document.querySelectorAll('#th-r3, #th-r4').forEach(th => th.classList.toggle('hidden', !showR3R4));
            document.querySelectorAll('.round-score').forEach(td => {
                const input = td.querySelector('input');
                if (input && (input.dataset.round === 'r3' || input.dataset.round === 'r4')) {
                    td.classList.toggle('hidden', !showR3R4);
                }
            });
            toggleButton.textContent = showR3R4 ? 'Hide Rounds 3 & 4' : 'Show Rounds 3 & 4';
            updateVenueStyle();
            sortAndRender();
            return true;
        }

        function calculateToPar(row) {
            const inputs = row.querySelectorAll('.score-input');
            let total = 0;
            let played = 0;
            inputs.forEach(input => {
                if (!input.parentElement.classList.contains('hidden')) {
                    const val = parseInt(input.value.trim());
                    if (!isNaN(val) && val > 0) {
                        total += val;
                        played++;
                    }
                }
            });
            if (played > 0) {
                const par = parseInt(courseParElement.textContent) || 72;
                return total - (par * played);
            }
            return null;
        }

        function updateRow(row) {
            const totalCell = row.querySelector('[data-type="total"]');
            const toParCell = row.querySelector('[data-type="topar"]');
            const inputs = row.querySelectorAll('.score-input');
            let total = 0;
            let played = 0;
            inputs.forEach(input => {
                if (!input.parentElement.classList.contains('hidden')) {
                    const val = parseInt(input.value.trim());
                    if (!isNaN(val) && val > 0) {
                        total += val;
                        played++;
                    }
                }
            });
            totalCell.textContent = total > 0 ? total : '-';
            if (total > 0) {
                const par = parseInt(courseParElement.textContent) || 72;
                const toPar = total - (par * played);
                toParCell.textContent = (toPar > 0 ? '+' : '') + (toPar === 0 ? 'E' : toPar);
                toParCell.className = 'to-par ' + (toPar < 0 ? 'under' : toPar > 0 ? 'over' : 'even');
            } else {
                toParCell.textContent = '-';
                toParCell.className = 'to-par even';
            }
        }

        function hasBonusData() {
            const bonusRows = bonusBody.querySelectorAll('tr');
            for (const row of bonusRows) {
                const fir = parseFloat(row.querySelector('.fir').textContent.trim());
                const gir = parseFloat(row.querySelector('.gir').textContent.trim());
                const scrambling = parseFloat(row.querySelector('.scrambling').textContent.trim());
                const ntp = parseFloat(row.querySelector('.ntp').textContent.trim());
                if ((!isNaN(fir) && fir > 0) || (!isNaN(gir) && gir > 0) || (!isNaN(scrambling) && scrambling > 0) || (!isNaN(ntp) && ntp > 0)) {
                    return true;
                }
            }
            return false;
        }

        function highlightBonusWinners() {
            bonusBody.querySelectorAll('.bonus-winner').forEach(cell => cell.classList.remove('bonus-winner'));
            if (!hasBonusData()) return;
            const bonusRows = Array.from(bonusBody.querySelectorAll('tr'));
            let maxFir = -1, maxGir = -1, maxScrambling = -1, minNtp = Infinity;
            bonusRows.forEach(row => {
                const fir = parseFloat(row.querySelector('.fir').textContent.trim());
                const gir = parseFloat(row.querySelector('.gir').textContent.trim());
                const scrambling = parseFloat(row.querySelector('.scrambling').textContent.trim());
                const ntp = parseFloat(row.querySelector('.ntp').textContent.trim());
                if (!isNaN(fir) && fir > 0 && fir > maxFir) maxFir = fir;
                if (!isNaN(gir) && gir > 0 && gir > maxGir) maxGir = gir;
                if (!isNaN(scrambling) && scrambling > 0 && scrambling > maxScrambling) maxScrambling = scrambling;
                if (!isNaN(ntp) && ntp > 0 && ntp < minNtp) minNtp = ntp;
            });
            bonusRows.forEach(row => {
                const firCell = row.querySelector('.fir');
                const girCell = row.querySelector('.gir');
                const scramblingCell = row.querySelector('.scrambling');
                const ntpCell = row.querySelector('.ntp');
                if (parseFloat(firCell.textContent.trim()) === maxFir && maxFir > 0) firCell.classList.add('bonus-winner');
                if (parseFloat(girCell.textContent.trim()) === maxGir && maxGir > 0) girCell.classList.add('bonus-winner');
                if (parseFloat(scramblingCell.textContent.trim()) === maxScrambling && maxScrambling > 0) scramblingCell.classList.add('bonus-winner');
                if (parseFloat(ntpCell.textContent.trim()) === minNtp && minNtp < Infinity) ntpCell.classList.add('bonus-winner');
            });
        }

        function addBonusToPrizes() {
            if (!hasBonusData()) return;
            const bonusRows = Array.from(bonusBody.querySelectorAll('tr'));
            const BONUS = getBonusCash();
            let firWinners = [], girWinners = [], scramblingWinners = [], ntpWinners = [];
            let maxFir = -1, maxGir = -1, maxScrambling = -1, minNtp = Infinity;
            bonusRows.forEach(row => {
                const fir = parseFloat(row.querySelector('.fir').textContent.trim());
                const gir = parseFloat(row.querySelector('.gir').textContent.trim());
                const scrambling = parseFloat(row.querySelector('.scrambling').textContent.trim());
                const ntp = parseFloat(row.querySelector('.ntp').textContent.trim());
                if (!isNaN(fir) && fir > 0) {
                    if (fir > maxFir) { maxFir = fir; firWinners = [row.dataset.player]; }
                    else if (fir === maxFir) firWinners.push(row.dataset.player);
                }
                if (!isNaN(gir) && gir > 0) {
                    if (gir > maxGir) { maxGir = gir; girWinners = [row.dataset.player]; }
                    else if (gir === maxGir) girWinners.push(row.dataset.player);
                }
                if (!isNaN(scrambling) && scrambling > 0) {
                    if (scrambling > maxScrambling) { maxScrambling = scrambling; scramblingWinners = [row.dataset.player]; }
                    else if (scrambling === maxScrambling) scramblingWinners.push(row.dataset.player);
                }
                if (!isNaN(ntp) && ntp > 0) {
                    if (ntp < minNtp) { minNtp = ntp; ntpWinners = [row.dataset.player]; }
                    else if (ntp === minNtp) ntpWinners.push(row.dataset.player);
                }
            });
            const awardBonus = (winners) => {
                winners.forEach(name => {
                    const row = tableBody.querySelector(`tr[data-player="${name}"]`);
                    if (row) {
                        const prizeCell = row.querySelector('[data-type="prize"]');
                        const current = parseInt(prizeCell.textContent.replace(/[^0-9]/g, '')) || 0;
                        prizeCell.textContent = '$' + (current + BONUS).toLocaleString();
                    }
                });
            };
            awardBonus(firWinners);
            awardBonus(girWinners);
            awardBonus(scramblingWinners);
            awardBonus(ntpWinners);
        }

        function calculatePrizes(scoredRows) {
            const fullPool = getCurrentPrizePool() * (isMajor() ? 2 : 1);
            const numPaid = 16;
            tableBody.querySelectorAll('[data-type="prize"]').forEach(cell => cell.textContent = '$0');
            if (scoredRows.length === 0) return;
            let currentPos = 1;
            let i = 0;
            let distributed = 0;
            while (i < scoredRows.length && currentPos <= numPaid) {
                const startPos = currentPos;
                let tieCount = 1;
                const startToPar = calculateToPar(scoredRows[i]);
                i++;
                while (i < scoredRows.length && calculateToPar(scoredRows[i]) === startToPar) {
                    tieCount++;
                    i++;
                }
                let prizeSum = 0;
                for (let p = startPos; p < startPos + tieCount; p++) {
                    if (p <= numPaid) prizeSum += fullPool * (payoutPercentages[p] / 100);
                }
                const prizePerPlayer = prizeSum / tieCount;
                for (let j = startPos - 1; j < startPos - 1 + tieCount && j < scoredRows.length; j++) {
                    const prizeCell = scoredRows[j].querySelector('[data-type="prize"]');
                    prizeCell.textContent = '$' + Math.round(prizePerPlayer).toLocaleString();
                }
                distributed += prizeSum;
                currentPos += tieCount;
            }
            if (distributed < fullPool && scoredRows.length < numPaid) {
                const remaining = fullPool - distributed;
                const extraPerPlayer = Math.round(remaining / scoredRows.length);
                scoredRows.forEach(row => {
                    const prizeCell = row.querySelector('[data-type="prize"]');
                    const current = parseInt(prizeCell.textContent.replace(/[^0-9]/g, '')) || 0;
                    prizeCell.textContent = '$' + (current + extraPerPlayer).toLocaleString();
                });
            }
        }

        function awardCurrentPointsToSeason(scoredRows) {
            if (scoredRows.length === 0) return;
            let pos = 1;
            let i = 0;
            while (i < scoredRows.length) {
                const startPos = pos;
                const startToPar = calculateToPar(scoredRows[i]);
                let tieCount = 1;
                i++;
                while (i < scoredRows.length && calculateToPar(scoredRows[i]) === startToPar) {
                    tieCount++;
                    i++;
                }
                let pointsSum = 0;
                for (let p = startPos; p < startPos + tieCount; p++) {
                    pointsSum += pointsTable[p - 1] || 4;
                }
                const pointsPerPlayer = pointsSum / tieCount;
                for (let j = startPos - 1; j < startPos - 1 + tieCount; j++) {
                    const playerName = scoredRows[j].dataset.player.trim();
                    addToSeasonPoints(playerName, Math.round(pointsPerPlayer));
                }
                pos += tieCount;
            }
        }

        function awardCurrentEventsToSeason(scoredRows) {
            scoredRows.forEach(row => {
                const playerName = row.dataset.player.trim();
                addToSeasonEvents(playerName);
            });
        }

        // NEW: HALL OF FAME LOGIC
        function updateHallOfFame() {
            const hofDisplay = document.getElementById('hof-display');
            if (!hofDisplay) return;
            hofDisplay.innerHTML = '';
            const sortedPlayers = Object.entries(seasonEarnings)
                .map(([name, earnings]) => ({ name, earnings }))
                .sort((a, b) => b.earnings - a.earnings)
                .slice(0, 3);
            const medals = ['ü•á', 'ü•à', 'ü•â'];
            sortedPlayers.forEach((player, index) => {
                const wins = eventHistory.filter(event => event.winner === player.name).length;
                const eventsPlayed = seasonEvents[player.name] || 0;
                const card = document.createElement('div');
                card.className = 'hof-card';
                card.innerHTML = `
                    <div style="font-size:40px;">${medals[index]}</div>
                    <div style="font-size:20px; font-weight:bold; margin:10px 0;">${player.name}</div>
                    <div class="hof-stat">Career Earnings: <span>$${player.earnings.toLocaleString()}</span></div>
                    <div class="hof-stat">Total Wins: <span>${wins}</span></div>
                    <div class="hof-stat">Events Played: <span>${eventsPlayed}</span></div>
                `;
                hofDisplay.appendChild(card);
            });
        }

        function sortAndRender() {
            const rows = Array.from(tableBody.children);
            rows.forEach(row => updateRow(row));
            const scoredRows = rows.filter(row => calculateToPar(row) !== null);
            const noScoreRows = rows.filter(row => calculateToPar(row) === null);
            scoredRows.sort((a, b) => calculateToPar(a) - calculateToPar(b));
            const allSortedRows = [...scoredRows, ...noScoreRows];
            calculatePrizes(scoredRows);
            addBonusToPrizes();
            highlightBonusWinners();
            let currentRank = 1;
            let prevToPar = null;
            let tieGroupSize = 0;
            allSortedRows.forEach((row, index) => {
                // Apply Grey Highlights to Top 5
                row.classList.remove('leaderboard-highlight', 'leaderboard-highlight-bottom');
                const currToPar = calculateToPar(row);
                if (currToPar === null) {
                    row.querySelector('.pos').textContent = '-';
                    row.querySelector('[data-type="prize"]').textContent = '$0';
                } else {
                    if (index < 15) {
                        row.classList.add('leaderboard-highlight');
                        if (index === 4) row.classList.add('leaderboard-highlight-bottom');
                    }
                    if (prevToPar !== null && currToPar !== prevToPar) {
                        currentRank += tieGroupSize;
                        tieGroupSize = 0;
                    }
                    tieGroupSize++;
                    const posText = tieGroupSize > 1 ? `T${currentRank}` : currentRank.toString();
                    row.querySelector('.pos').textContent = posText;
                }
                prevToPar = currToPar;
                tableBody.appendChild(row);
            });
            allSortedRows.forEach(row => {
                const playerName = row.dataset.player || row.querySelector('.player-text').textContent.trim();
                const bonusRow = bonusBody.querySelector(`tr[data-player="${playerName}"]`);
                if (bonusRow) {
                    bonusRow.querySelector('.season-points').textContent = getSeasonPoints(playerName).toLocaleString();
                    bonusRow.querySelector('.season-earnings').textContent = '$' + getSeasonEarnings(playerName).toLocaleString();
                    bonusRow.querySelector('.season-events').textContent = getSeasonEvents(playerName);
                }
            });
            const bonusRows = Array.from(bonusBody.children);
            bonusRows.forEach(row => {
                row.classList.remove('season-top50');
                row.classList.remove('season-top50-bottom-border');
            });
            bonusRows.sort((a, b) => {
                const pointsA = getSeasonPoints(a.dataset.player);
                const pointsB = getSeasonPoints(b.dataset.player);
                if (pointsB !== pointsA) return pointsB - pointsA;
                const earningsA = getSeasonEarnings(a.dataset.player);
                const earningsB = getSeasonEarnings(b.dataset.player);
                if (earningsB !== earningsA) return earningsB - earningsA;
                return getSeasonEvents(b.dataset.player) - getSeasonEvents(a.dataset.player);
            });
            const totalPlayers = bonusRows.length;
            if (totalPlayers > 0) {
                const topCount = Math.ceil(totalPlayers / 2);
                for (let i = 0; i < topCount && i < totalPlayers; i++) {
                    bonusRows[i].classList.add('season-top50');
                }
                if (topCount > 0) {
                    bonusRows[topCount - 1].classList.add('season-top50-bottom-border');
                }
            }
            bonusRows.forEach(row => bonusBody.appendChild(row));
            updateHallOfFame();
            saveData();
        }

        function awardCurrentPrizesToSeason() {
            tableBody.querySelectorAll('tr').forEach(row => {
                const name = row.dataset.player || row.querySelector('.player-text').textContent.trim();
                const prizeCell = row.querySelector('[data-type="prize"]');
                const prizeAmount = parseInt(prizeCell.textContent.replace(/[^0-9]/g, '')) || 0;
                if (prizeAmount > 0) addToSeasonEarnings(name, prizeAmount);
            });
        }

        function resetScoresOnly() {
            awardCurrentPrizesToSeason();
            const rows = Array.from(tableBody.children);
            rows.forEach(row => updateRow(row));
            const scoredRows = rows.filter(row => calculateToPar(row) !== null).sort((a, b) => calculateToPar(a) - calculateToPar(b));
            awardCurrentPointsToSeason(scoredRows);
            awardCurrentEventsToSeason(scoredRows);
            addToHistory();
            increasePrizePool();
            increaseEventCount();
            tableBody.querySelectorAll('tr').forEach(row => {
                const name = row.dataset.player || row.querySelector('.player-text').textContent.trim() || "New Player";
                const newMain = createMainRow({ name: name });
                newMain.dataset.player = name;
                const newBonus = createBonusRow({ name: name, fir: '', gir: '', scrambling: '', ntp: '' });
                newBonus.dataset.player = name;
                row.replaceWith(newMain);
                const oldBonus = bonusBody.querySelector(`tr[data-player="${name}"]`);
                if (oldBonus) oldBonus.replaceWith(newBonus);
            });
            courseParElement.textContent = '72';
            showR3R4 = false;
            document.querySelectorAll('#th-r3, #th-r4').forEach(th => th.classList.add('hidden'));
            document.querySelectorAll('.round-score').forEach(cell => {
                const input = cell.querySelector('input');
                if (input && (input.dataset.round === 'r3' || input.dataset.round === 'r4')) cell.classList.add('hidden');
            });
            toggleButton.textContent = 'Show Rounds 3 & 4';
            sortAndRender();
        }

        function addPlayer() {
            const name = newPlayerInput.value.trim();
            if (!name) return;
            const existing = Array.from(tableBody.querySelectorAll('tr')).map(r => r.dataset.player.toLowerCase());
            if (existing.includes(name.toLowerCase())) { alert('Player exists'); return; }
            tableBody.appendChild(createMainRow({ name: name }));
            bonusBody.appendChild(createBonusRow({ name: name }));
            newPlayerInput.value = '';
            sortAndRender();
        }

        tableBody.addEventListener('keydown', (e) => {
            if (!e.target.classList.contains('score-input')) return;
            const input = e.target;
            const currentCell = input.parentElement;
            const currentRow = currentCell.parentElement;
            const allRows = Array.from(tableBody.children);
            const rowIndex = allRows.indexOf(currentRow);
            const scoreCells = Array.from(currentRow.querySelectorAll('.round-score')).filter(cell => !cell.classList.contains('hidden'));
            const cellIndex = scoreCells.indexOf(currentCell);
            let nextInput = null;
            if (e.key === 'Enter') {
                e.preventDefault();
                updateRow(currentRow);
                sortAndRender();
                if (cellIndex < scoreCells.length - 1) nextInput = scoreCells[cellIndex + 1].querySelector('input');
                else if (rowIndex < allRows.length - 1) {
                    const nr = Array.from(allRows[rowIndex + 1].querySelectorAll('.round-score')).filter(c => !c.classList.contains('hidden'));
                    if (nr.length > 0) nextInput = nr[0].querySelector('input');
                }
            } else if (e.key === 'ArrowRight' && cellIndex < scoreCells.length - 1) nextInput = scoreCells[cellIndex + 1].querySelector('input');
            else if (e.key === 'ArrowLeft' && cellIndex > 0) nextInput = scoreCells[cellIndex - 1].querySelector('input');
            else if (e.key === 'ArrowDown' && rowIndex < allRows.length - 1) {
                const nr = Array.from(allRows[rowIndex + 1].querySelectorAll('.round-score')).filter(c => !c.classList.contains('hidden'));
                nextInput = (nr[cellIndex] || nr[0])?.querySelector('input');
            } else if (e.key === 'ArrowUp' && rowIndex > 0) {
                const pr = Array.from(allRows[rowIndex - 1].querySelectorAll('.round-score')).filter(c => !c.classList.contains('hidden'));
                nextInput = (pr[cellIndex] || pr[pr.length - 1])?.querySelector('input');
            }
            if (nextInput) { nextInput.focus(); nextInput.select(); }
        });

        bonusBody.addEventListener('keydown', (e) => {
            if (!e.target.classList.contains('editable')) return;
            const cell = e.target;
            const row = cell.closest('tr');
            const allRows = Array.from(bonusBody.querySelectorAll('tr'));
            const rowIndex = allRows.indexOf(row);
            const editables = Array.from(row.querySelectorAll('.editable'));
            const cellIndex = editables.indexOf(cell);
            let next = null;
            if (e.key === 'Enter') {
                e.preventDefault();
                if (cellIndex < editables.length - 1) next = editables[cellIndex + 1];
                else if (rowIndex < allRows.length - 1) next = allRows[rowIndex+1].querySelectorAll('.editable')[0];
            } else if (e.key === 'ArrowDown' && rowIndex < allRows.length - 1) next = allRows[rowIndex+1].querySelectorAll('.editable')[cellIndex];
            else if (e.key === 'ArrowUp' && rowIndex > 0) next = allRows[rowIndex-1].querySelectorAll('.editable')[cellIndex];
            if (next) next.focus();
        });

        function exportToJSON() {
            const data = {
                timestamp: new Date().toISOString(),
                header: headerField.textContent.trim(),
                date: dateField.textContent.trim(),
                venue: venueField.textContent.trim(),
                coursePar: courseParElement.textContent.trim(),
                prizePool: getCurrentPrizePool(),
                eventCount: getEventCount(),
                seasonEarnings, seasonPoints, seasonEvents, eventHistory,
                players: []
            };
            tableBody.querySelectorAll('tr').forEach(row => {
                const name = row.querySelector('.player-text').textContent.trim();
                const bonusRow = bonusBody.querySelector(`tr[data-player="${name}"]`);
                data.players.push({
                    name: name,
                    console: row.querySelector('.console-icon').classList[2],
                    country: row.querySelector('.country-input').value,
                    r1: row.querySelectorAll('.score-input')[0].value,
                    r2: row.querySelectorAll('.score-input')[1].value,
                    r3: row.querySelectorAll('.score-input')[2].value,
                    r4: row.querySelectorAll('.score-input')[3].value,
                    fir: bonusRow?.querySelector('.fir').textContent.trim(),
                    gir: bonusRow?.querySelector('.gir').textContent.trim(),
                    scrambling: bonusRow?.querySelector('.scrambling').textContent.trim(),
                    ntp: bonusRow?.querySelector('.ntp').textContent.trim()
                });
            });
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `emerald-tour-backup-${new Date().toISOString().slice(0,10)}.json`;
            a.click();
        }

        addPlayerButton.addEventListener('click', addPlayer);
        newPlayerInput.addEventListener('keydown', e => { if (e.key === 'Enter') addPlayer(); });
        venueField.addEventListener('input', () => { updateVenueStyle(); sortAndRender(); });
        
        bonusBody.addEventListener('blur', e => {
            if (e.target.classList.contains('bonus-input')) {
                const val = parseFloat(e.target.textContent);
                e.target.textContent = isNaN(val) ? '' : val.toFixed(2);
                sortAndRender();
            }
        }, true);

        tableBody.addEventListener('blur', e => {
            if (e.target.classList.contains('score-input')) {
                updateRow(e.target.closest('tr'));
                sortAndRender();
            }
        }, true);

        toggleButton.addEventListener('click', () => {
            showR3R4 = !showR3R4;
            document.querySelectorAll('#th-r3, #th-r4').forEach(th => th.classList.toggle('hidden'));
            document.querySelectorAll('.round-score').forEach(cell => {
                const input = cell.querySelector('input');
                if (input && (input.dataset.round === 'r3' || input.dataset.round === 'r4')) cell.classList.toggle('hidden', !showR3R4);
            });
            toggleButton.textContent = showR3R4 ? 'Hide Rounds 3 & 4' : 'Show Rounds 3 & 4';
            sortAndRender();
        });

        newTournamentButton.addEventListener('click', resetScoresOnly);
        clearSeasonButton.addEventListener('click', clearSeasonEarnings);
        document.getElementById('export-json').addEventListener('click', exportToJSON);
        courseParElement.addEventListener('input', () => sortAndRender());
        historyToggle.addEventListener('click', () => {
            historyTable.classList.toggle('hidden');
            historyToggle.textContent = historyTable.classList.contains('hidden') ? 'Season Event History ‚ñº' : 'Season Event History ‚ñ≤';
        });

        document.getElementById('export-png').addEventListener('click', () => {
            html2canvas(document.querySelector('.leaderboard-container'), { scale: 2 }).then(canvas => {
                const link = document.createElement('a');
                link.download = `emerald-leaderboard-${new Date().toISOString().slice(0,10)}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            });
        });

        // UPDATED: ROBUST IMPORT JSON
        document.getElementById('import-json').addEventListener('click', () => {
            if (!confirm('Overwrite current data?')) return;
            const input = document.createElement('input');
            input.type = 'file';
            input.onchange = e => {
                const reader = new FileReader();
                reader.onload = f => {
                    const data = JSON.parse(f.target.result);
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
                    if (data.seasonEarnings) localStorage.setItem(SEASON_EARNINGS_KEY, JSON.stringify(data.seasonEarnings));
                    if (data.seasonPoints) localStorage.setItem(SEASON_POINTS_KEY, JSON.stringify(data.seasonPoints));
                    if (data.seasonEvents) localStorage.setItem(SEASON_EVENTS_KEY, JSON.stringify(data.seasonEvents));
                    if (data.eventHistory) localStorage.setItem(HISTORY_KEY, JSON.stringify(data.eventHistory));
                    if (data.prizePool) localStorage.setItem(PRIZE_KEY, data.prizePool.toString());
                    if (data.eventCount) localStorage.setItem(EVENT_COUNT_KEY, data.eventCount.toString());
                    location.reload();
                };
                reader.readAsText(e.target.files[0]);
            };
            input.click();
        });

        if (!loadData()) {
            sortAndRender();
        }
    </script>
</body>
</html>